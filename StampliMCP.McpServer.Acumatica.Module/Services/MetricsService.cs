using System.Diagnostics.Metrics;

namespace StampliMCP.McpServer.Acumatica.Services;

/// <summary>
/// Metrics service using System.Diagnostics.Metrics API for observability.
/// Compatible with OpenTelemetry and dotnet-counters.
/// </summary>
public class MetricsService
{
    private readonly Meter _meter;
    private readonly Counter<long> _toolCalls;
    private readonly Histogram<double> _duration;
    private readonly Counter<long> _tokens;
    private readonly Counter<long> _errors;

    public MetricsService(IMeterFactory factory)
    {
        _meter = factory.Create("StampliMCP.Acumatica", "1.0.0");

        _toolCalls = _meter.CreateCounter<long>(
            "mcp.tool.calls",
            unit: "calls",
            description: "Total number of MCP tool invocations");

        _duration = _meter.CreateHistogram<double>(
            "mcp.tool.duration",
            unit: "ms",
            description: "MCP tool execution duration in milliseconds");

        _tokens = _meter.CreateCounter<long>(
            "mcp.tool.tokens",
            unit: "tokens",
            description: "Total tokens generated by MCP tools");

        _errors = _meter.CreateCounter<long>(
            "mcp.tool.errors",
            unit: "errors",
            description: "Total MCP tool errors");
    }

    /// <summary>
    /// Record metrics for a tool execution.
    /// </summary>
    /// <param name="toolName">Name of the tool (e.g., "kotlin_tdd_workflow")</param>
    /// <param name="durationMs">Execution duration in milliseconds</param>
    /// <param name="tokensGenerated">Number of tokens in response (content length)</param>
    /// <param name="success">Whether execution succeeded</param>
    /// <param name="additionalTags">Optional additional tags for metrics</param>
    public void RecordToolExecution(
        string toolName,
        double durationMs,
        long tokensGenerated,
        bool success,
        params KeyValuePair<string, object?>[] additionalTags)
    {
        var tags = new List<KeyValuePair<string, object?>>
        {
            new("tool", toolName),
            new("success", success)
        };

        if (additionalTags != null)
        {
            tags.AddRange(additionalTags);
        }

        _toolCalls.Add(1, tags.ToArray());
        _duration.Record(durationMs, new KeyValuePair<string, object?>("tool", toolName));

        if (tokensGenerated > 0)
        {
            _tokens.Add(tokensGenerated, new KeyValuePair<string, object?>("tool", toolName));
        }

        if (!success)
        {
            _errors.Add(1, new KeyValuePair<string, object?>("tool", toolName));
        }
    }

    /// <summary>
    /// Record a tool execution with command context (for stateful tools).
    /// </summary>
    public void RecordToolExecution(
        string toolName,
        string command,
        double durationMs,
        long tokensGenerated,
        bool success,
        string? flowName = null)
    {
        var tags = new List<KeyValuePair<string, object?>>
        {
            new("command", command)
        };

        if (!string.IsNullOrEmpty(flowName))
        {
            tags.Add(new("flow", flowName));
        }

        RecordToolExecution(toolName, durationMs, tokensGenerated, success, tags.ToArray());
    }
}
