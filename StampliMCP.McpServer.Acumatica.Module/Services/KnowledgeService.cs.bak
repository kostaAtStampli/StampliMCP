using System.Collections.Concurrent;
using System.Reflection;
using System.Text.Json;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;
using StampliMCP.Shared.Models;
using StampliMCP.Shared.Services;

namespace StampliMCP.McpServer.Acumatica.Services;

public sealed class KnowledgeService(ILogger<KnowledgeService> logger, IMemoryCache cache)
{
    private readonly Assembly _assembly = typeof(KnowledgeService).Assembly;
    private readonly ConcurrentDictionary<string, List<Operation>> _operationsByCategory = new();
    private static readonly JsonSerializerOptions _jsonOptions = new()
    {
        PropertyNameCaseInsensitive = true
    };
    private static readonly MemoryCacheEntryOptions _cacheOptions = new()
    {
        SlidingExpiration = TimeSpan.FromMinutes(10),
        Size = 1
    };

    private async Task<string> ReadEmbeddedResourceAsync(string resourcePath, CancellationToken ct = default)
    {
        // Convert file path to embedded resource name
        // Knowledge/categories.json -> StampliMCP.McpServer.Acumatica.Knowledge.categories.json
        var resourceName = $"StampliMCP.McpServer.Acumatica.Knowledge.{resourcePath.Replace('/', '.').Replace('\\', '.')}";

        using var stream = _assembly.GetManifestResourceStream(resourceName);
        if (stream == null)
        {
            logger.LogWarning("Embedded resource not found: {ResourceName}", resourceName);
            throw new FileNotFoundException($"Resource {resourceName} not found in assembly");
        }

        using var reader = new StreamReader(stream);
        return await reader.ReadToEndAsync(ct);
    }

    public async Task<List<Category>> GetCategoriesAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "categories",
            async entry =>
            {
                try
                {
                    entry.SetOptions(_cacheOptions);
                    var json = await ReadEmbeddedResourceAsync("categories.json", ct);
                    var data = JsonSerializer.Deserialize<CategoriesFile>(json, _jsonOptions);
                    var categories = data?.Categories ?? [];
                    logger.LogInformation("Loaded {Count} categories from embedded resources", categories.Count);
                    return categories;
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Error loading categories from embedded resources");
                    return new List<Category>();
                }
            }) ?? [];
    }

    public async Task<List<Operation>> GetOperationsByCategoryAsync(string category, CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            $"operations_{category}",
            async entry =>
            {
                try
                {
                    entry.SetOptions(_cacheOptions);

                    // Map category to the appropriate knowledge file
                    var knowledgeFile = category switch
                    {
                        "payments" => "operations/payments.json",
                        "purchaseOrders" => "operations/purchaseOrders.json",
                        "accounts" => "operations/accounts.json",
                        "fields" => "operations/fields.json",
                        "customFields" => "custom-field-operations.json",
                        "admin" => "operations/admin.json",
                        "vendors" => "operations/vendors.json",
                        "items" => "operations/items.json",
                        "retrieval" => "operations/retrieval.json",
                        "utility" => "operations/utility.json",
                        "other" => "operations/other.json",
                        _ => $"operations/{category}.json" // Fallback to operations subfolder
                    };

                    var json = await ReadEmbeddedResourceAsync(knowledgeFile, ct);

                    // Parse the JSON structure which has operations as a nested object
                    var document = JsonDocument.Parse(json);
                    var ops = new List<Operation>();

                    if (document.RootElement.TryGetProperty("operations", out var operationsElement))
                    {
                        // Handle both array and object formats
                        if (operationsElement.ValueKind == System.Text.Json.JsonValueKind.Array)
                        {
                            // Array format: { "operations": [...] } (operations/*.json files)
                            ops = JsonSerializer.Deserialize<List<Operation>>(operationsElement.GetRawText(), _jsonOptions) ?? [];
                        }
                        else if (operationsElement.ValueKind == System.Text.Json.JsonValueKind.Object)
                        {
                            // Object format: { "operations": { "opName": {...}, ... } } (root files)
                            foreach (var opProperty in operationsElement.EnumerateObject())
                            {
                                // Normalize schema differences: some files use "operationName" instead of "method"
                                try
                                {
                                    var element = opProperty.Value;
                                    string raw = element.GetRawText();

                                    // If method exists, use as-is
                                    bool hasMethod = element.TryGetProperty("method", out _);
                                    bool hasOperationName = element.TryGetProperty("operationName", out var opNameEl);

                                    if (!hasMethod && hasOperationName)
                                    {
                                        // Build a JsonObject and inject "method": operationName
                                        var node = System.Text.Json.Nodes.JsonNode.Parse(raw) as System.Text.Json.Nodes.JsonObject;
                                        if (node != null && !node.ContainsKey("method"))
                                        {
                                            node["method"] = opNameEl.GetString();
                                            raw = node.ToJsonString();
                                        }
                                    }

                                    var op = JsonSerializer.Deserialize<Operation>(raw, _jsonOptions);
                                    if (op != null)
                                    {
                                        ops.Add(op);
                                    }
                                }
                                catch (Exception ex)
                                {
                                    logger.LogWarning(ex, "Failed to parse operation entry for category {Category}", category);
                                }
                            }
                        }
                    }
                    else if (document.RootElement.TryGetProperty("Operations", out var operationsArray))
                    {
                        // Old structure: { "Operations": [...] }
                        ops = JsonSerializer.Deserialize<List<Operation>>(operationsArray.GetRawText(), _jsonOptions) ?? [];
                    }

                    // Also store in concurrent dictionary for fast lookup
                    _operationsByCategory.TryAdd(category, ops);

                    logger.LogInformation("Loaded {Count} operations for {Category} from {File}", ops.Count, category, knowledgeFile);
                    return ops;
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Error loading operations for category {Category} from embedded resources", category);
                    return new List<Operation>();
                }
            }) ?? [];
    }

    public async Task<Operation?> FindOperationAsync(string methodName, CancellationToken ct = default)
    {
        var categories = await GetCategoriesAsync(ct);

        foreach (var category in categories)
        {
            var ops = await GetOperationsByCategoryAsync(category.Name, ct);
            var op = ops.FirstOrDefault(o => o.Method.Equals(methodName, StringComparison.OrdinalIgnoreCase));
            if (op is not null) return op;
        }

        return null;
    }

    public async Task<List<Operation>> GetAllOperationsAsync(CancellationToken ct = default)
    {
        var categories = await GetCategoriesAsync(ct);
        var allOperations = new List<Operation>();

        foreach (var category in categories)
        {
            var ops = await GetOperationsByCategoryAsync(category.Name, ct);
            allOperations.AddRange(ops);
        }

        return allOperations;
    }

    public async Task<List<EnumMapping>> GetEnumsAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "enums",
            async entry =>
            {
                try
                {
                    entry.SetOptions(_cacheOptions);
                    var json = await ReadEmbeddedResourceAsync("enums.json", ct);
                    var data = JsonSerializer.Deserialize<EnumsFile>(json, _jsonOptions);
                    var enums = data?.Enums ?? [];
                    logger.LogInformation("Loaded {Count} enum mappings from embedded resources", enums.Count);
                    return enums;
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Error loading enums from embedded resources");
                    return new List<EnumMapping>();
                }
            }) ?? [];
    }

    public async Task<object> GetTestConfigAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "test-config",
            async entry =>
            {
                try
                {
                    entry.SetOptions(_cacheOptions);
                    var json = await ReadEmbeddedResourceAsync("test-config.json", ct);
                    var config = JsonSerializer.Deserialize<object>(json) ?? new { };
                    logger.LogInformation("Loaded test configuration from embedded resources");
                    return config;
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Error loading test configuration from embedded resources");
                    return new { error = "Failed to load test configuration" };
                }
            }) ?? new { };
    }

    public async Task<object> GetKotlinErrorPatternsAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "kotlin-error-patterns",
            async entry =>
            {
                entry.SetOptions(_cacheOptions);
                var json = await ReadEmbeddedResourceAsync("kotlin.error-patterns-kotlin.json", ct);
                var patterns = JsonSerializer.Deserialize<object>(json) ?? new { };
                logger.LogInformation("Loaded Kotlin error patterns from embedded resources");
                return patterns;
            }) ?? new { };
    }

    public async Task<object> GetKotlinIntegrationAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "kotlin-integration",
            async entry =>
            {
                entry.SetOptions(_cacheOptions);
                var json = await ReadEmbeddedResourceAsync("kotlin.kotlin-integration.json", ct);
                var integration = JsonSerializer.Deserialize<object>(json) ?? new { };
                logger.LogInformation("Loaded Kotlin integration strategy from embedded resources");
                return integration;
            }) ?? new { };
    }

    public async Task<object> GetKotlinMethodSignaturesAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "kotlin-method-signatures",
            async entry =>
            {
                entry.SetOptions(_cacheOptions);
                var json = await ReadEmbeddedResourceAsync("kotlin.method-signatures.json", ct);
                var signatures = JsonSerializer.Deserialize<object>(json) ?? new { };
                logger.LogInformation("Loaded Kotlin method signatures from embedded resources");
                return signatures;
            }) ?? new { };
    }

    public async Task<object> GetKotlinTestConfigAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "kotlin-test-config",
            async entry =>
            {
                entry.SetOptions(_cacheOptions);
                var json = await ReadEmbeddedResourceAsync("kotlin.test-config-kotlin.json", ct);
                var config = JsonSerializer.Deserialize<object>(json) ?? new { };
                logger.LogInformation("Loaded Kotlin test configuration from embedded resources");
                return config;
            }) ?? new { };
    }

    public async Task<string> GetKotlinGoldenPatternsAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "kotlin-golden-patterns",
            async entry =>
            {
                entry.SetOptions(_cacheOptions);
                var content = await ReadEmbeddedResourceAsync("kotlin.GOLDEN_PATTERNS.md", ct);
                logger.LogInformation("Loaded Kotlin golden patterns from embedded resources");
                return content;
            }) ?? string.Empty;
    }

    public async Task<string> GetKotlinArchitectureAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "kotlin-architecture",
            async entry =>
            {
                entry.SetOptions(_cacheOptions);
                var content = await ReadEmbeddedResourceAsync("kotlin.KOTLIN_ARCHITECTURE.md", ct);
                logger.LogInformation("Loaded Kotlin architecture guide from embedded resources");
                return content;
            }) ?? string.Empty;
    }

    public async Task<string> GetKotlinTddWorkflowAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "kotlin-tdd-workflow",
            async entry =>
            {
                entry.SetOptions(_cacheOptions);
                var content = await ReadEmbeddedResourceAsync("kotlin.TDD_WORKFLOW.md", ct);
                logger.LogInformation("Loaded Kotlin TDD workflow from embedded resources");
                return content;
            }) ?? string.Empty;
    }

    public async Task<object> GetKotlinGoldenReferenceAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "kotlin-golden-reference",
            async entry =>
            {
                try
                {
                    entry.SetOptions(_cacheOptions);
                    var json = await ReadEmbeddedResourceAsync("kotlin-golden-reference.json", ct);
                    var reference = JsonSerializer.Deserialize<object>(json, _jsonOptions);
                    logger.LogInformation("Loaded Kotlin golden reference (exportVendor example) from embedded resources");
                    return reference ?? new { };
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Error loading Kotlin golden reference from embedded resources");
                    return new { error = "Failed to load Kotlin golden reference" };
                }
            }) ?? new { };
    }

    public async Task<JsonDocument?> GetModernInfrastructureAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "modern-infrastructure",
            async entry =>
            {
                try
                {
                    entry.SetOptions(_cacheOptions);
                    var json = await ReadEmbeddedResourceAsync("modern-infrastructure.json", ct);
                    var document = JsonDocument.Parse(json);
                    logger.LogInformation("Loaded modern infrastructure (LiveErpTestBase, DSLs, ENV1) from embedded resources");
                    return document;
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Error loading modern infrastructure from embedded resources");
                    return null;
                }
            });
    }

    public async Task<ErrorCatalog> GetErrorCatalogAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "error-catalog",
            async entry =>
            {
                try
                {
                    entry.SetOptions(_cacheOptions);
                    var json = await ReadEmbeddedResourceAsync("error-catalog.json", ct);
                    var catalog = JsonSerializer.Deserialize<ErrorCatalog>(json, _jsonOptions);
                    logger.LogInformation("Loaded error catalog from embedded resources");
                    return catalog ?? new ErrorCatalog();
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Error loading error catalog from embedded resources");
                    return new ErrorCatalog();
                }
            }) ?? new ErrorCatalog();
    }

    public async Task<List<ErrorDetail>> GetOperationErrorsAsync(string operationMethod, CancellationToken ct = default)
    {
        var catalog = await GetErrorCatalogAsync(ct);
        var errors = new List<ErrorDetail>();

        if (catalog.OperationErrors != null && catalog.OperationErrors.TryGetValue(operationMethod, out var opErrors))
        {
            if (opErrors.Validation != null)
                errors.AddRange(opErrors.Validation);
            if (opErrors.BusinessLogic != null)
                errors.AddRange(opErrors.BusinessLogic);
        }

        return errors;
    }

    public async Task<object> GetBaseClassesAsync(CancellationToken ct = default)
    {
        return await cache.GetOrCreateAsync(
            "base-classes",
            async entry =>
            {
                try
                {
                    entry.SetOptions(_cacheOptions);
                    var json = await ReadEmbeddedResourceAsync("base-classes.json", ct);
                    var baseClasses = JsonSerializer.Deserialize<object>(json, _jsonOptions);
                    logger.LogInformation("Loaded base classes from embedded resources");
                    return baseClasses ?? new { };
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Error loading base classes from embedded resources");
                    return new { error = "Failed to load base classes" };
                }
            }) ?? new { };
    }
}

file sealed record CategoriesFile(List<Category> Categories);
file sealed record OperationsFile(string Category, List<Operation> Operations);
file sealed record EnumsFile(List<EnumMapping> Enums);

// Error catalog models
public sealed record ErrorCatalog
{
    public List<ErrorDetail>? AuthenticationErrors { get; init; }
    public Dictionary<string, OperationErrorSet>? OperationErrors { get; init; }
    public List<ApiError>? ApiErrors { get; init; }
}

public sealed record OperationErrorSet
{
    public List<ErrorDetail>? Validation { get; init; }
    public List<ErrorDetail>? BusinessLogic { get; init; }
}

public sealed record ErrorDetail
{
    public string? Field { get; init; }
    public string? Condition { get; init; }
    public string? Type { get; init; }
    public required string Message { get; init; }
    public CodeLocation? Location { get; init; }
    public string? TestAssertion { get; init; }
}

public sealed record ApiError
{
    public int Code { get; init; }
    public required string Message { get; init; }
    public string? Handling { get; init; }
    public CodeLocation? Location { get; init; }
}

public sealed record CodeLocation
{
    public required string File { get; init; }
    public string? Lines { get; init; }
}

